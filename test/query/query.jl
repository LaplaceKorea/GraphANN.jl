struct DiskANNComparison
    window_size::Int
    num_neighbors::Int
    expected_accuracy::Float64
end
DiskANNComparison(x::Tuple) = DiskANNComparison(x...)

# There's one test where GraphANN returns 0.9689999999999999 while DiskANN
# returns 0.9690000000000001.
#
# I mean ... come one - these are practically the same.
# SO, we make a slightly looser floating point definition for floating point
# approximate equality or greater.
approx_or_greater(a, b) = (a â‰ˆ b) || (a > b)

@testset "Testing Query with DiskANN" begin
    # Parameters taken from running the DiskANN code on the index included in the
    # "data" directory.
    #
    # This exercises both the correctness of the query algorithm as well as our computation
    # of the "recall" metric.
    comparisons = DiskANNComparison.([
        (10 , 1 , 100.0),
        (10 , 5 , 98.6 ),
        (10 , 10, 96.9 ),
        (20 , 1 , 100.0),
        (20 , 5 , 100.0),
        (20 , 10, 99.4 ),
        (20 , 20, 98.6 ),
        (30 , 1 , 100.0),
        (30 , 5 , 100.0),
        (30 , 10, 99.7 ),
        (30 , 20, 99.45),
        (30 , 30, 99.2 ),
        (50 , 1 , 100.0),
        (50 , 5 , 100.0),
        (50 , 10, 99.8 ),
        (50 , 20, 99.8 ),
        (50 , 30, 99.8 ),
        (50 , 50, 99.62),
        (100, 1 , 100.0),
        (100, 5 , 100.0),
        (100, 10, 100.0),
        (100, 20, 100.0),
        (100, 30, 100.0),
        (100, 50, 99.94),
        (100, 100, 99.85),
    ])

    # Step 1 - Load up the index generated by DiskANN.
    graph = GraphANN.load_graph(
        GraphANN.DiskANNLoader(),
        diskann_index,
        # Sift Small has 10000 base elements.
        10000,
    )

    # Load in siftsmall dataset, queries, and ground truth.
    data = GraphANN.load_vecs(GraphANN.Euclidean{128,Float32}, dataset_path)
    meta = GraphANN.MetaGraph(graph, data)

    queries = GraphANN.load_vecs(GraphANN.Euclidean{128,Float32}, query_path)

    # Add "1" to ground truth to convert from index-0 to Julia's index-1
    ground_truth = GraphANN.load_vecs(groundtruth_path) .+ 1

    # Set up the algorithm.
    start = GraphANN.medioid(data)
    for comparison in comparisons
        algo = GraphANN.GreedySearch(comparison.window_size)

        # Obtain the approximate nearest neighbors
        ids = GraphANN.searchall(
            algo,
            meta,
            start,
            queries;
            num_neighbors = comparison.num_neighbors,
        )

        recall_values = GraphANN.recall(ground_truth, ids)

        # These are based on the same algorithm, so check for approximate floating
        # point equality.
        #
        # At some point, our implementation might become better, so we'll have to adjust
        # the comparison.
        @test isapprox(100 * mean(recall_values), comparison.expected_accuracy)
    end

    # Sanity check
    @test !isapprox(100.0, 99.94)
end
